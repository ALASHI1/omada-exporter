package omada

import (
	"fmt"
	"net/url"

	"go.uber.org/zap"
)

const maxPages = 10 // as a precaution, stop fetching clients after this many pages

// ClientsResult was autogenerated with `gojson`.
type ClientsResult struct {
	ErrorCode int64 `json:"errorCode"`
	Msg       string
	Result    struct {
		CurrentPage int64              `json:"currentPage"`
		CurrentSize int64              `json:"currentSize"`
		TotalRows   int64              `json:"totalRows"`
		Data        []*ConnectedClient `json:"data"`
	} `json:"result"`
}

// ConnectedClient was autogenerated with `gojson`.
type ConnectedClient struct {
	Active         bool   `json:"active"`
	Activity       int64  `json:"activity"`
	ApMAC          string `json:"apMac"`
	ApName         string `json:"apName"`
	AuthStatus     int64  `json:"authStatus"`
	Channel        int64  `json:"channel"`
	ConnectDevType string `json:"connectDevType"`
	ConnectType    int64  `json:"connectType"`
	DeviceType     string `json:"deviceType"`
	DownPacket     int64  `json:"downPacket"`
	Guest          bool   `json:"guest"`
	HostName       string `json:"hostName"`
	IP             string `json:"ip"`
	LastSeen       int64  `json:"lastSeen"`
	MAC            string `json:"mac"`
	Manager        bool   `json:"manager"`
	Name           string `json:"name"`
	PowerSave      bool   `json:"powerSave"`
	RadioID        int64  `json:"radioId"`
	RSSI           int64  `json:"rssi"`
	RxRate         int64  `json:"rxRate"`
	SignalLevel    int64  `json:"signalLevel"`
	SignalRank     int64  `json:"signalRank"`
	SSID           string `json:"ssid"`
	TrafficDown    int64  `json:"trafficDown"`
	TrafficUp      int64  `json:"trafficUp"`
	TxRate         int64  `json:"txRate"`
	UpPacket       int64  `json:"upPacket"`
	Uptime         int64  `json:"uptime"`
	WifiMode       int64  `json:"wifiMode"`
	Wireless       bool   `json:"wireless"`
}

// dedupeClients removes duplicate clients based on their MAC address.
func dedupeClients(in []*ConnectedClient) []*ConnectedClient {
	seen := make(map[string]struct{}, len(in))
	out := make([]*ConnectedClient, 0, len(in))

	for _, item := range in {
		if _, ok := seen[item.MAC]; !ok {
			seen[item.MAC] = struct{}{}
			out = append(out, item)
		}
	}

	return out
}

// ConnectedClients returns statistics for active wireless clients
// across all known Access Points.
func (c *Client) ConnectedClients(site string) ([]*ConnectedClient, error) {
	var clients []*ConnectedClient
	currentPage := 1
	for ; currentPage <= maxPages; currentPage++ {
		var r ClientsResult
		get := func() error {
			path := fmt.Sprintf("/api/v2/sites/%s/clients?token=%s&currentPage=%d&currentPageSize=100&filters.active=true", url.QueryEscape(site), url.QueryEscape(c.Token()), currentPage)
			err := c.getJSON(path, &r)
			if err != nil {
				return err
			}
			if r.ErrorCode == -1200 {
				return errTokenExpired
			}
			if r.ErrorCode != 0 {
				return fmt.Errorf("%d: %s", r.ErrorCode, r.Msg)
			}

			return nil
		}

		if err := c.retryOnce(get); err != nil {
			return nil, err
		}

		clients = append(clients, r.Result.Data...)

		if int64(len(clients)) >= r.Result.TotalRows || len(r.Result.Data) == 0 {
			break
		}
	}

	if currentPage > maxPages {
		c.logger.Warn("stopped fetching clients after too many pages",
			zap.Int("pages", maxPages),
			zap.Int("clients", len(clients)),
		)
	}

	// client list may change between page fetches and prometheus
	// won't like it if we emit the same timeseries more than once.
	clients = dedupeClients(clients)

	return clients, nil
}
