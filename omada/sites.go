package omada

import (
	"fmt"
	"net/url"

	"go.uber.org/zap"
)

// SitesResult was autogenerated with `gojson`.
type SitesResult struct {
	ErrorCode int64 `json:"errorCode"`
	Msg       string
	Result    struct {
		CurrentPage int64   `json:"currentPage"`
		CurrentSize int64   `json:"currentSize"`
		TotalRows   int64   `json:"totalRows"`
		Data        []*Site `json:"data"`
	} `json:"result"`
}

// Site was autogenerated with `gojson`.
type Site struct {
	AlertNum                  int64  `json:"alertNum"`
	Key                       string `json:"key"`
	Lan                       bool   `json:"lan"`
	LanDeviceConnectedNum     int64  `json:"lanDeviceConnectedNum"`
	LanDeviceDisconnectedNum  int64  `json:"lanDeviceDisconnectedNum"`
	LanGuestNum               int64  `json:"lanGuestNum"`
	LanUserNum                int64  `json:"lanUserNum"`
	Name                      string `json:"name"`
	Primary                   bool   `json:"primary"`
	Region                    string `json:"region"`
	Wan                       bool   `json:"wan"`
	Wlan                      bool   `json:"wlan"`
	WlanDeviceConnectedNum    int64  `json:"wlanDeviceConnectedNum"`
	WlanDeviceDisconnectedNum int64  `json:"wlanDeviceDisconnectedNum"`
	WlanDeviceIsolatedNum     int64  `json:"wlanDeviceIsolatedNum"`
	WlanGuestNum              int64  `json:"wlanGuestNum"`
	WlanUserNum               int64  `json:"wlanUserNum"`
}

// dedupeSites removes duplicate sites based on their name.
func dedupeSites(in []*Site) []*Site {
	seen := make(map[string]struct{}, len(in))
	out := make([]*Site, 0, len(in))

	for _, site := range in {
		if _, ok := seen[site.Name]; !ok {
			seen[site.Name] = struct{}{}
			out = append(out, site)
		}
	}

	return out
}

// Sites returns information about each "site" known to the controller.
func (c *Client) Sites() ([]*Site, error) {
	var sites []*Site
	currentPage := 1
	for ; currentPage <= maxPages; currentPage++ {
		var r SitesResult
		get := func() error {
			path := fmt.Sprintf("/api/v2/sites?token=%s&currentPage=%d&currentPageSize=100", url.QueryEscape(c.Token()), currentPage)
			err := c.getJSON(path, &r)
			if err != nil {
				return err
			}
			if r.ErrorCode == -1200 {
				return errTokenExpired
			}
			if r.ErrorCode != 0 {
				return fmt.Errorf("%v: %s", r.ErrorCode, r.Msg)
			}

			return nil
		}

		if err := c.retryOnce(get); err != nil {
			return nil, err
		}

		sites = append(sites, r.Result.Data...)

		if int64(len(sites)) >= r.Result.TotalRows || len(r.Result.Data) == 0 {
			break
		}
	}

	if currentPage > maxPages {
		c.logger.Warn("stopped fetching sites after too many pages",
			zap.Int("pages", maxPages),
			zap.Int("sites", len(sites)),
		)
	}

	// filter duplicate results due to site list changing across pages
	sites = dedupeSites(sites)

	return sites, nil
}
